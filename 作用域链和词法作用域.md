```js
function bar() {
  console.log(name);
}

function foo() {
  var name = "alice";
  bar();
}

var name = "jack";

foo();

// jack

```

> 上面这段代码执行结果是 jack，为什么不是 alice？

我们知道当某个变量在当前作用域内部不存在时，js会通过作用域链去上一级的作用域内查找，那么作用域链的建立时机就很关键。造成上面那个现象的原因是作用域链的建立时机是在词法解析阶段，而非运行时。所以只要你的函数在写的时候没写成嵌套结构，无论调用时的嵌套有多复杂，它的上一级作用域都是全局作用域。

> 为什么作用域链要在词法解析时确定，而非运行时？

已知：

全局的执行上下文是在词法解析完成后便创建了，然后当代码执行到某个函数时：

- 从heap中取出函数的定义
- 执行函数体、创建函数的执行上下文、构建scope chain

猜想：

在构建scope chain的时候直接去AST上面查找函数的层级信息，比去调用栈中查找要简单。