```js
function bar() {
  console.log(name);
}

function foo() {
  var name = "alice";
  bar();
}

var name = "jack";

foo();

// jack

```

> 上面这段代码执行结果是 jack，为什么不是 alice？

我们知道当某个变量在当前作用域内部不存在时，js会通过作用域链去上一级的作用域内查找，那么作用域链的建立时机就很关键。造成上面那个现象的原因是作用域链的建立时机是在词法解析阶段，而非运行时。所以只要你的函数在写的时候没写成嵌套结构，无论调用时的嵌套有多复杂，它的上一级作用域都是全局作用域。

> 为什么作用域链要在词法解析时确定，而非运行时？

已知：

全局的执行上下文是在词法解析完成后便创建了，然后当代码执行到某个函数时：

- 从heap中取出函数的定义
- 执行函数体、创建函数的执行上下文、构建scope chain

猜想：

在构建scope chain的时候直接去AST上面查找函数的层级信息，比去调用栈中查找要简单。

`宏任务和微任务`

有观点认为一段js代码也是一个宏任务，每个宏任务中包含了一个微任务队列，每次宏任务执行完成后直接在宏任务的执行上下文中，js引擎会去检查微任务队列并执行。
微任务的出现的意义在于平衡执行效率和任务的实时性要求，比如Dom变化事件的处理，需要一定的实时性，但又不能太频繁地阻塞同步代码的执行。

`setTimeout是如何实现的`

- 将setTimeout的的函数放入一个延迟任务队列
- 每次执行完一个宏任务后，去check这个延迟任务队列，是否有任务的执行时间已经到达，如果到达了则将其清除，并在宏任务队列中添加一个任务，即setTimeout的执行任务